using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GedasFX.SourceGenerators.gRPC.MediatR;

[Generator]
public class RpcMediatorIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // https://andrewlock.net/exploring-dotnet-6-part-9-source-generator-updates-incremental-generators/
        // https://github.com/davidwengier/SourceGeneratorTemplate/blob/main/SourceGenerator/IncrementalGenerator.cs

        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node is AliasQualifiedNameSyntax { Alias.Identifier.Text: "grpc", Name.Identifier.Text: "BindServiceMethod" },
            transform: static (context, _) => GetSemanticTarget(context)).Where(c => c is not null);

        context.RegisterSourceOutput(classDeclarations, Execute!);
    }

    private static void Execute(SourceProductionContext context, ClassDeclarationSyntax rpcService)
    {
        foreach (var member in rpcService.Members)
        {
            if (member is not MethodDeclarationSyntax method)
                continue;

            var requestType = (QualifiedNameSyntax)method.ParameterList.Parameters[0].Type!;
            var requestNamespace = requestType.Left.ToString().Substring(8);
            var requestClassType = requestType.Right.ToString();

            var resultType = ((GenericNameSyntax)((QualifiedNameSyntax)method.ReturnType).Right).TypeArgumentList.Arguments[0].ToString();

            var source = @$"// <auto-generated />
namespace {requestNamespace}
{{
    public partial class {requestClassType} : MediatR.IRequest<{resultType}> {{ }}
}}";

            var hint = $"{$"{requestNamespace}.{requestClassType}".Replace('.', '_')}.g.cs";
            try
            {
                context.AddSource(hint, source);
            }
            catch (ArgumentException e)
            {
                if (e.Message != $"The hintName '{hint}' of the added source file must be unique within a generator. (Parameter 'hintName')")
                    throw;
            }
        }
    }

    private static ClassDeclarationSyntax? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var syntaxNode = (AliasQualifiedNameSyntax)context.Node;

        var parent = syntaxNode.Parent;
        while (parent is not ClassDeclarationSyntax and not null)
        {
            parent = parent.Parent;
        }

        return parent as ClassDeclarationSyntax;
    }
}