using System;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace GedasFX.SourceGenerators.gRPC.MediatR;

public struct Configuration
{
    public bool EnableCQRS { get; set; }
}

[Generator]
public class RpcMediatorIncrementalGenerator : IIncrementalGenerator
{
    private static string GeneratorVersion { get; } = typeof(RpcMediatorIncrementalGenerator).Assembly.GetName().Version.ToString(3);
    private static string GeneratedCodeAttribute { get; } = $@"[global::System.CodeDom.Compiler.GeneratedCode(""GedasFX.SourceGenerators.gRPC.MediatR"", ""{GeneratorVersion}"")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // https://andrewlock.net/exploring-dotnet-6-part-9-source-generator-updates-incremental-generators/
        // https://github.com/davidwengier/SourceGeneratorTemplate/blob/main/SourceGenerator/IncrementalGenerator.cs
        // https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md

        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => node is AliasQualifiedNameSyntax { Alias.Identifier.Text: "grpc", Name.Identifier.Text: "BindServiceMethod" },
                transform: GetSemanticTarget
            )
            .Where(c => c is not null);

        var configurationProvider = context.AnalyzerConfigOptionsProvider.Select(ExtractConfiguration);

        context.RegisterSourceOutput(classDeclarations.Combine(configurationProvider), GenerateContracts!);
        context.RegisterSourceOutput(classDeclarations, GenerateServices!);
    }

    private static Configuration ExtractConfiguration(AnalyzerConfigOptionsProvider s, CancellationToken _ = default)
    {
        s.GlobalOptions.TryGetValue("build_property.MediatR_EnableCQRS", out var enableCqrs);

        return new Configuration { EnableCQRS = enableCqrs is "true" };
    }


    private static void GenerateContracts(SourceProductionContext context, (ClassDeclarationSyntax RpcService, Configuration Configuration) args)
    {
        foreach (var member in args.RpcService.Members)
        {
            if (member is not MethodDeclarationSyntax method)
                continue;

            var requestType = (QualifiedNameSyntax)method.ParameterList.Parameters[0].Type!;
            var requestNamespace = requestType.Left.ToString().Substring(8);
            var requestClassType = requestType.Right.ToString();

            var resultType = ((GenericNameSyntax)((QualifiedNameSyntax)method.ReturnType).Right).TypeArgumentList.Arguments[0];

            var source = @$"// <auto-generated />

namespace {requestNamespace}
{{
    {GeneratedCodeAttribute}
    public partial class {requestClassType} : MediatR.I{GetRequestCategory(requestClassType, args.Configuration.EnableCQRS)}Request<{resultType}> {{ }}
}}";

            var hint = $"{$"{requestNamespace}.{requestClassType}".Replace('.', '_')}.g.cs";
            try
            {
                context.AddSource(hint, source);
            }
            catch (ArgumentException e)
            {
                if (e.Message != $"The hintName '{hint}' of the added source file must be unique within a generator. (Parameter 'hintName')")
                    throw;
            }
        }
    }

    private static void GenerateServices(SourceProductionContext context, ClassDeclarationSyntax rpcService)
    {
        var @namespace = (rpcService.Parent?.Parent as NamespaceDeclarationSyntax)?.Name;
        if (@namespace == null) // Classes without namespaces are not supported.
            return;

        var parentClass = ((ClassDeclarationSyntax)rpcService.Parent!).Identifier;

        var sb = new StringBuilder();
        foreach (var member in rpcService.Members)
        {
            if (member is not MethodDeclarationSyntax method) continue;

            sb.Append(@$"
            public override {method.ReturnType} {method.Identifier}{method.ParameterList}
            {{
                return _mediator.Send(request, context.CancellationToken);
            }}");
        }

        var source = $@"// <auto-generated />
#pragma warning disable 8981

using grpc = global::Grpc.Core;

namespace {@namespace}
{{
    public partial class {parentClass}
    {{
        {GeneratedCodeAttribute}
        public partial class {parentClass}Service : {parentClass}Base
        {{
            private readonly MediatR.IMediator _mediator;

            public {parentClass}Service(MediatR.IMediator mediator)
            {{
                _mediator = mediator;
            }}
{sb}
        }}
    }}
}}";

        context.AddSource($"{$"{@namespace}.{parentClass}".Replace('.', '_')}.g.cs", source);
    }


    private static string GetRequestCategory(string requestClassType, bool useCqrs)
    {
        if (!useCqrs)
            return string.Empty;

        if (requestClassType.EndsWith("Command"))
            return "Command";

        if (requestClassType.EndsWith("Query"))
            return "Query";

        return string.Empty;
    }

    private static ClassDeclarationSyntax? GetSemanticTarget(GeneratorSyntaxContext context, CancellationToken _ = default)
    {
        var syntaxNode = (AliasQualifiedNameSyntax)context.Node;

        var parent = syntaxNode.Parent;
        while (parent is not ClassDeclarationSyntax and not null)
        {
            parent = parent.Parent;
        }

        return parent as ClassDeclarationSyntax;
    }
}