using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GedasFX.SourceGenerators.gRPC.MediatR;

[Generator]
public class RpcMediatorIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // https://andrewlock.net/exploring-dotnet-6-part-9-source-generator-updates-incremental-generators/
        // https://github.com/davidwengier/SourceGeneratorTemplate/blob/main/SourceGenerator/IncrementalGenerator.cs

        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node is AliasQualifiedNameSyntax { Alias.Identifier.Text: "grpc", Name.Identifier.Text: "BindServiceMethod" },
            transform: static (context, _) => GetSemanticTarget(context)).Where(c => c is not null);

        context.RegisterSourceOutput(classDeclarations, GenerateContracts!);
        context.RegisterSourceOutput(classDeclarations, GenerateServices!);

        context.RegisterPostInitializationOutput(e => e.AddSource("MediatR.g.cs", @"// <auto-generated />

namespace MediatR
{
    public partial interface ICommandRequest<out TResponse> : IRequest<TResponse>, IBaseCommandRequest { }
    public partial interface IQueryRequest<out TResponse> : IRequest<TResponse>, IBaseQueryRequest { }

    public partial interface IBaseCommandRequest : IBaseRequest { }
    public partial interface IBaseQueryRequest : IBaseRequest { }
}
"));
    }

    private static void GenerateContracts(SourceProductionContext context, ClassDeclarationSyntax rpcService)
    {
        foreach (var member in rpcService.Members)
        {
            if (member is not MethodDeclarationSyntax method)
                continue;

            var requestType = (QualifiedNameSyntax)method.ParameterList.Parameters[0].Type!;
            var requestNamespace = requestType.Left.ToString().Substring(8);
            var requestClassType = requestType.Right.ToString();

            var resultType = ((GenericNameSyntax)((QualifiedNameSyntax)method.ReturnType).Right).TypeArgumentList.Arguments[0];

            var source = @$"// <auto-generated />

namespace {requestNamespace}
{{
    public partial class {requestClassType} : MediatR.I{GetRequestCategory(requestClassType)}Request<{resultType}> {{ }}
}}";

            var hint = $"{$"{requestNamespace}.{requestClassType}".Replace('.', '_')}.g.cs";
            try
            {
                context.AddSource(hint, source);
            }
            catch (ArgumentException e)
            {
                if (e.Message != $"The hintName '{hint}' of the added source file must be unique within a generator. (Parameter 'hintName')")
                    throw;
            }
        }
    }

    private static string GetRequestCategory(string requestClassType)
    {
        if (requestClassType.EndsWith("Command"))
            return "Command";

        if (requestClassType.EndsWith("Query"))
            return "Query";

        return string.Empty;
    }

    private static void GenerateServices(SourceProductionContext context, ClassDeclarationSyntax rpcService)
    {
        // rpcService.Members

        var @namespace = ((NamespaceDeclarationSyntax)rpcService.Parent!.Parent!).Name;
        var parentClass = ((ClassDeclarationSyntax)rpcService.Parent).Identifier;

        var sb = new StringBuilder();
        foreach (var member in rpcService.Members)
        {
            if (member is not MethodDeclarationSyntax method) continue;

            sb.Append(@$"
            public override {method.ReturnType} {method.Identifier}{method.ParameterList}
            {{
                return _mediator.Send(request, context.CancellationToken);
            }}");
        }

        var source = $@"// <auto-generated />

using grpc = global::Grpc.Core;

namespace {@namespace}
{{
    public partial class {parentClass}
    {{
        public partial class {parentClass}Service : {parentClass}Base
        {{
            private readonly MediatR.IMediator _mediator;

            public {parentClass}Service(MediatR.IMediator mediator)
            {{
                _mediator = mediator;
            }}
{sb}
        }}
    }}
}}";

        context.AddSource($"{$"{@namespace}.{parentClass}".Replace('.', '_')}.g.cs", source);
    }

    private static ClassDeclarationSyntax? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var syntaxNode = (AliasQualifiedNameSyntax)context.Node;

        var parent = syntaxNode.Parent;
        while (parent is not ClassDeclarationSyntax and not null)
        {
            parent = parent.Parent;
        }

        return parent as ClassDeclarationSyntax;
    }
}